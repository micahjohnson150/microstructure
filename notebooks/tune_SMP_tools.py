import pickle
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from importlib import reload
import sys
from scipy.stats import binned_statistic
import warnings
from scipy.optimize import minimize
sys.path.insert(1,'../../snowmicropyn')
import snowmicropyn
from snowmicropyn import density_ssa

C20_window=1

def get_mct_frame(site):

    """Serves up a dataframe of micro-CT SSA data for a given site"""

    # Load a dictionary of dataframes stored as a pickle file
    # The pickle file itself is generated by notebook: CheckOutCT.ipynb

    frames = pickle.load(open('../data/microCT/processed_mCT.p', 'rb'))

    # Select your dataframe from the dictionary by using the site code as the key

    mct_df = frames[site]

    # Drop duplicate samples that have the same average height

    mct_df = mct_df.drop_duplicates(subset='height_ave (cm)',keep="first")

    mct_df.set_index('height_ave (cm)', inplace=True)
    
    return mct_df

def get_ssa(p, coeffs_dict):

    """Generates a dataframe of SSA from a given dict of coefficients"""

    # Call Mel's version of snowmicropyn with coeffs_dict.

    # Coeffs dict must have the following format:

    # coeffs_dict = {'density': [a, b, c, d],
    #               'ssa':[x,y,z],
    #               'equation':eqn}

    # Where 'eqn' is 'ssa' or 'l_ex' depending on whether you're using C20 or P15

    df = snowmicropyn.density_ssa.calc(p.samples,
                                            coeff_model=coeffs_dict,
                                            window=C20_window,
                                            overlap=50)

    # Crop dataframe to remove points below ground detection
    # Probably unnecessary

    df = df[(df['distance'] < p.ground)]

    # Get some z coords that are distance up from grnd detection
    # Also convert z coords to cm from mm
    # This is how the microCT data are indexed

    df['distance_up'] = (p.ground - df['distance'])/10

    df.set_index('distance_up',inplace=True)

    df.sort_index() # Probably unnecessary

    df.dropna(how='any') # Drop nans that inevitably appear due to windowing
    
    return df

def resample_SMP_to_mCT(mct_df, df):

    """The SMP outputs a huge number of SSA values at very high spatial resolution.
    This function averages those values to produce one SSA figure that corresponds
    to every microCT measurement."""

    # This is necessary for some reason. Pointers and shit.
    com_df = mct_df.copy()

    # Every microCT sample has height_min, and height_max numbers.
    # This list comprehension grabs all SMP-derived SSA values between those values.
    # It averages all these SSA values, and assigns the result to the row corresponding
    # to the relevant microCT sample.

    com_df['ssa'] = [np.nanmean(df['ssa'][(df.index < u) & (df.index > l)]) 
                      for l, u in zip(mct_df['height_min (cm)'], mct_df['height_max (cm)'])   ]
        
    return com_df

def compare_smp_to_mct(coeffs_list,mct_df,p,eqn='ssa'):

    """Wrapper function that takes a microCT profile, some SMP data, and produces a unified,
    resampled dataframe with SSAs from both, so they can be compared."""

    # Embed your list of three SMP coeffs in a dictionary
    # You must do this to interface with Mel's fork of snowmicropyn
    
    coeffs_dict = {'density': [295.8, 65.1, -43.2, 47.1],
                  'ssa':coeffs_list,
                  'equation':eqn}

    # Get the high spatial resolution SMP profile using the coefficients you've passed

    df = get_ssa(p, coeffs_dict)

    # Resample your hi-res SMP profile to the z-coords of the microCT profile
    
    com_df = resample_SMP_to_mCT(mct_df, df)

    # Return the unified dataframe of microCT and SMP SSA data
    
    return(com_df)

def calc_RMSE(coeffs_list,mct_df,p, print=True, eqn='ssa'):

    """A wrapper for passing to scipy.minimize.

    This requires a microCT profile, an SMP profile and some coords.

    It returns the RMSE between the SMP & mCT SSA values"""
    
    com_df = compare_smp_to_mct(coeffs_list,mct_df,p,eqn)
    
    RMSE = np.sqrt(np.nanmean(np.square(com_df['SSA (m2/kg)']-com_df['ssa'])))
    
    if print: print(RMSE)
    
    return RMSE
